

<!DOCTYPE html>
<html lang="ru">
    <head>
        <title>Компоненты — Vue.js</title>
        <meta charset="utf-8">
        <meta name="description" content="Vue.js — Прогрессивный JavaScript-фреймворк">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

        <link rel="alternate" hreflang="x-default" href="https://vuejs.org/v2/guide/components.html">
        <link rel="alternate" hreflang="zh" href="https://cn.vuejs.org/v2/guide/components.html">
        <link rel="alternate" hreflang="ja" href="https://jp.vuejs.org/v2/guide/components.html">
        <link rel="alternate" hreflang="ru" href="https://ru.vuejs.org/v2/guide/components.html">
        <link rel="alternate" hreflang="ko" href="https://kr.vuejs.org/v2/guide/components.html">
        <link rel="alternate" hreflang="pt-BR" href="https://br.vuejs.org/v2/guide/components.html">
        <link rel="alternate" hreflang="fr" href="https://fr.vuejs.org/v2/guide/components.html">

        <meta property="og:type" content="article">
        <meta property="og:title" content="Компоненты — Vue.js">
        <meta property="og:description" content="Vue.js — Прогрессивный JavaScript-фреймворк">
        <meta property="og:image" content="https://ru.vuejs.org//images/logo.png">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Компоненты — Vue.js">
        <meta name="twitter:description" content="Vue.js — Прогрессивный JavaScript-фреймворк">
        <meta name="twitter:image" content="https://ru.vuejs.org/images/logo.png">

        <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
        <link rel="icon" type="image/png" sizes="192x192"  href="/images/icons/android-icon-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png">
        <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
        <link rel="icon" href="/images/logo.png" type="image/png">

        <meta name="msapplication-TileColor" content="#4fc08d">
        <meta name="theme-color" content="#4fc08d">

        <meta name="msapplication-config" content="browserconfig.xml">
        <link rel="manifest" href="/manifest.json">

        <link href='//fonts.googleapis.com/css?family=Roboto Mono' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Dosis:500&text=Vue.js' rel='stylesheet' type='text/css'>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

        <!-- main page styles -->
        <link rel="stylesheet" href="/css/page.css">

        <!-- this needs to be loaded before guide's inline scripts -->
        <script src="/js/vue.js"></script>
        <script>window.PAGE_TYPE = "guide"</script>

        <!-- ga -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-46852172-1', 'ru.vuejs.org');

          ga('send', 'pageview');
        </script>

        <!-- vimeo analytics -->
        <script type="text/javascript" defer="defer" src="https://extend.vimeocdn.com/ga/72160148.js"></script>
    </head>
    <body class="docs">
        <div id="mobile-bar" >
            <a class="menu-button"></a>
            <a class="logo" href="/"></a>
        </div>
        <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png">
    <span>Vue.js</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">Обучение</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/v2/guide/" class="nav-link current">Руководство</a></li>
      <li><a href="/v2/api/" class="nav-link">API</a></li>
      <li><a href="/v2/style-guide/" class="nav-link">Рекомендации</a></li>
      <li><a href="/v2/examples/" class="nav-link">Примеры</a></li>
      <li><a href="/v2/cookbook/" class="nav-link">Cookbook</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Экосистема</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Помощь</h4></li>
    <li><ul>
      <li><a href="https://forum.vuejs.org/" class="nav-link" target="_blank">Форум</a></li>
      <li><a href="https://chat.vuejs.org/" class="nav-link" target="_blank">Чат</a></li>
    </ul></li>
    <li><h4>Инструментарий</h4></li>
    <li>
      <ul>
        <li><a href="https://github.com/vuejs/vue-devtools" class="nav-link" target="_blank">Инструменты разработчика</a></li>
        <li><a href="https://vuejs-templates.github.io/webpack" class="nav-link" target="_blank">Шаблон Webpack</a></li>
        <li><a href="https://vue-loader.vuejs.org" class="nav-link" target="_blank">Vue Loader</a></li>
      </ul>
    </li>
    <li><h4>Официальные плагины</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
      <li><a href="https://ssr.vuejs.org/" class="nav-link" target="_blank">Vue Server Renderer</a></li>
    </ul></li>
    <li><h4>Новости</h4></li>
    <li><ul>
      <li><a href="https://news.vuejs.org" class="nav-link" target="_blank">Еженедельные новости</a></li>
      <li><a href="https://github.com/vuejs/roadmap" class="nav-link" target="_blank">Roadmap</a></li>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Блог</a></li>
      <li><a href="https://vuejsjob.com/?ref=vuejs" class="nav-link" target="_blank">Вакансии</a></li>
    </ul></li>
    <li><h4>Списки ресурсов</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Официальные репозитории</a></li>
      <li><a href="https://curated.vuejs.org/" class="nav-link" target="_blank">Vue Curated</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue</a></li>
    </ul></li>
  </ul>
</li>

<li>
  <a href="/v2/guide/team.html" class="nav-link team">Команда</a>
</li>
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Поддержать Vue</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">Единоразовые пожертвования</a></li>
      <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Повторяющиеся взносы</a></li>
      <li><a href="https://vue.threadless.com" target="_blank" class="nav-link">Магазин футболок</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Переводы</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://cn.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://br.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://fr.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Français</a></li>
    <li><a href="https://vi.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Tiếng Việt</a></li>
  </ul>
</li>


  </ul>
</div>

        
            <div id="main" class="fix-sidebar">
                
                    
    <div class="sidebar">
    <div class="sidebar-inner">
        <ul class="main-menu">
            <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">Обучение</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/v2/guide/" class="nav-link current">Руководство</a></li>
      <li><a href="/v2/api/" class="nav-link">API</a></li>
      <li><a href="/v2/style-guide/" class="nav-link">Рекомендации</a></li>
      <li><a href="/v2/examples/" class="nav-link">Примеры</a></li>
      <li><a href="/v2/cookbook/" class="nav-link">Cookbook</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Экосистема</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Помощь</h4></li>
    <li><ul>
      <li><a href="https://forum.vuejs.org/" class="nav-link" target="_blank">Форум</a></li>
      <li><a href="https://chat.vuejs.org/" class="nav-link" target="_blank">Чат</a></li>
    </ul></li>
    <li><h4>Инструментарий</h4></li>
    <li>
      <ul>
        <li><a href="https://github.com/vuejs/vue-devtools" class="nav-link" target="_blank">Инструменты разработчика</a></li>
        <li><a href="https://vuejs-templates.github.io/webpack" class="nav-link" target="_blank">Шаблон Webpack</a></li>
        <li><a href="https://vue-loader.vuejs.org" class="nav-link" target="_blank">Vue Loader</a></li>
      </ul>
    </li>
    <li><h4>Официальные плагины</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
      <li><a href="https://ssr.vuejs.org/" class="nav-link" target="_blank">Vue Server Renderer</a></li>
    </ul></li>
    <li><h4>Новости</h4></li>
    <li><ul>
      <li><a href="https://news.vuejs.org" class="nav-link" target="_blank">Еженедельные новости</a></li>
      <li><a href="https://github.com/vuejs/roadmap" class="nav-link" target="_blank">Roadmap</a></li>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Блог</a></li>
      <li><a href="https://vuejsjob.com/?ref=vuejs" class="nav-link" target="_blank">Вакансии</a></li>
    </ul></li>
    <li><h4>Списки ресурсов</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Официальные репозитории</a></li>
      <li><a href="https://curated.vuejs.org/" class="nav-link" target="_blank">Vue Curated</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue</a></li>
    </ul></li>
  </ul>
</li>

<li>
  <a href="/v2/guide/team.html" class="nav-link team">Команда</a>
</li>
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Поддержать Vue</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">Единоразовые пожертвования</a></li>
      <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Повторяющиеся взносы</a></li>
      <li><a href="https://vue.threadless.com" target="_blank" class="nav-link">Магазин футболок</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Переводы</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://cn.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://br.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://fr.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Français</a></li>
    <li><a href="https://vi.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Tiếng Việt</a></li>
  </ul>
</li>


        </ul>
        <div class="list">
            <div id="sidebar-sponsors-special">
  <div class="main-sponsor">
    <span>Специальные спонсоры</span>
    <div>
    <a href="https://stdlib.com" target="_blank" class="logo">
      <img src="/images/stdlib.png">
    </a>
    <a href="https://www.bitsrc.io/?utm_source=vue&utm_medium=vue&utm_campaign=vue&utm_term=vue&utm_content=vue" target="_blank" class="logo">
      <img src="/images/bit-wide.png">
    </a>
    </div>
  </div>
</div>

<div id="sidebar-sponsors-platinum">
  <div class="main-sponsor">
    <span>Спонсоры на Patreon</span>
    <div>
    <a href="http://tooltwist.com/" target="_blank" class="logo">
      <img src="/images/tooltwist.png">
    </a>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" class="logo">
      <img src="/images/vueschool.png">
    </a>
    <a href="https://www.datacamp.com/careers?utm_source=vuejs&utm_medium=sidebar" target="_blank" class="logo">
      <img src="/images/datacamp.png">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    Поддержите Vue.js
  </a>
</div>

            <h2>
                
                Руководство
                
                    <select class="version-select">
                        <option value="SELF" selected>2.x</option>
                        <option value="v1">1.0</option>
                        <option value="012">0.12</option>
                        <option value="011">0.11</option>
                    </select>
                
            </h2>
            <ul class="menu-root">
    
        
        
            
                <li><h3>Основы</h3></li>
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/installation.html" class="sidebar-link">Установка</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/index.html" class="sidebar-link">Введение</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/instance.html" class="sidebar-link">Экземпляр Vue</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/syntax.html" class="sidebar-link">Синтаксис шаблонов</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/computed.html" class="sidebar-link">Вычисляемые свойства и слежение</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/class-and-style.html" class="sidebar-link">Работа с классами и стилями</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/conditional.html" class="sidebar-link">Условный рендеринг</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/list.html" class="sidebar-link">Рендеринг списков</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/events.html" class="sidebar-link">Обработка событий</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/forms.html" class="sidebar-link">Работа с формами</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/components.html" class="sidebar-link current">Компоненты</a>
        </li>
    
        
        
            
            
                <li><h3>Переходы & Анимации</h3></li>
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/transitions.html" class="sidebar-link">Анимирование списков и появления/исчезновения</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/transitioning-state.html" class="sidebar-link">Анимирование переходов между состояниями</a>
        </li>
    
        
        
            
            
            
                <li><h3>Переиспользование & Композиция</h3></li>
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/mixins.html" class="sidebar-link">Примеси</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/custom-directive.html" class="sidebar-link">Пользовательские директивы</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/render-function.html" class="sidebar-link">Render-функции и JSX</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/plugins.html" class="sidebar-link">Плагины</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/filters.html" class="sidebar-link">Фильтры</a>
        </li>
    
        
        
            
            
            
            
                <li><h3>Инструментарий</h3></li>
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/deployment.html" class="sidebar-link">Развёртывание на production</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/single-file-components.html" class="sidebar-link">Однофайловые компоненты</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/unit-testing.html" class="sidebar-link">Модульное тестирование</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/typescript.html" class="sidebar-link">Поддержка TypeScript</a>
        </li>
    
        
        
            
            
            
            
            
                <li><h3>Масштабирование</h3></li>
            
            
            
            
        
        <li>
            <a href="/v2/guide/routing.html" class="sidebar-link">Роутинг</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/state-management.html" class="sidebar-link">Управление состоянием приложения</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/ssr.html" class="sidebar-link">SSR. Рендеринг на стороне сервера</a>
        </li>
    
        
        
            
            
            
            
            
            
                <li><h3>Продвинутые темы</h3></li>
            
            
            
        
        <li>
            <a href="/v2/guide/reactivity.html" class="sidebar-link">Подробно о реактивности</a>
        </li>
    
        
        
            
            
            
            
            
            
            
                <li><h3>Вопросы миграции</h3></li>
            
            
        
        <li>
            <a href="/v2/guide/migration.html" class="sidebar-link">Миграция с Vue 1.x</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/migration-vue-router.html" class="sidebar-link">Миграция с Vue Router 0.7.x</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/migration-vuex.html" class="sidebar-link">Миграция с Vuex 0.6.x на 1.0</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
                <li><h3>Мета</h3></li>
            
        
        <li>
            <a href="/v2/guide/comparison.html" class="sidebar-link">Сравнение с другими фреймворками</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/join.html" class="sidebar-link">Присоединяйтесь к сообществу Vue.js!</a>
        </li>
    
        
        
            
            
            
            
            
            
            
            
        
        <li>
            <a href="/v2/guide/team.html" class="sidebar-link">Познакомьтесь с командой</a>
        </li>
    
</ul>

        </div>
    </div>
</div>


<div class="content guide with-sidebar components-guide">
    
      
        <div id="ad">
  <script>
    (function () {
      var s = document.createElement('script')
      s.setAttribute('async', '')
      s.src = '//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=vuejs'
      s.id = '_carbonads_js'
      document.getElementById('ad').appendChild(s)
    })()
  </script>
</div>

      
    
    
      <h1>Компоненты</h1>
    
    
      <h2 id="Что-такое-компоненты"><a href="#Что-такое-компоненты" class="headerlink" title="Что такое компоненты?"></a>Что такое компоненты?</h2><p>Компоненты — это одна из самых мощных возможностей Vue. Компоненты расширяют базовые HTML-элементы, позволяя инкапсулировать повторно используемый код. Не вдаваясь в подробности, можно сказать, что компоненты — это пользовательские элементы, к которым компилятор Vue привязывает определённое поведение. В некоторых случаях компоненты также можно задать с помощью нативных элементов, расширенных специальным атрибутом <code>is</code>.</p>
<p>Все компоненты Vue также являются экземплярами Vue и поэтому принимают один и тот же объект параметров (за исключением нескольких опций, специфичных для корневого компонента) и предоставляют те же хуки жизненного цикла.</p>
<h2 id="Использование-компонентов"><a href="#Использование-компонентов" class="headerlink" title="Использование компонентов"></a>Использование компонентов</h2><h3 id="Глобальная-регистрация"><a href="#Глобальная-регистрация" class="headerlink" title="Глобальная регистрация"></a>Глобальная регистрация</h3><p>В предыдущих разделах мы научились создавать экземпляры Vue:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#some-element'</span>,</span><br><span class="line">  <span class="comment">// опции</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Зарегистрировать глобальный компонент можно с помощью <code>Vue.component(tagName, options)</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// опции</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p class="tip">Обратите внимание, что Vue не требует соблюдения <a href="https://www.w3.org/TR/custom-elements/#concepts" target="_blank" rel="noopener">правил W3C</a> для пользовательских имён тегов (таких как требования использования только нижнего регистра и применения дефисов), хотя следование этим соглашениям считается хорошей практикой.</p>

<p>Зарегистрированный компонент можно использовать в шаблоне экземпляра как пользовательский элемент <code>&lt;my-component&gt;&lt;/my-component&gt;</code>. Компонент обязательно должен быть зарегистрирован <strong>до создания корневого экземпляра Vue</strong>. Вот полный пример:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// регистрация</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;Пользовательский компонент!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// создание корневого экземпляра</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Результатом рендеринга будет:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Пользовательский компонент!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div id="example" class="demo">
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<div>Пользовательский компонент!</div>'
})
new Vue({ el: '#example' })
</script>

<h3 id="Локальные-компоненты"><a href="#Локальные-компоненты" class="headerlink" title="Локальные компоненты"></a>Локальные компоненты</h3><p>Необязательно регистрировать все компоненты глобально. Можно сделать компонент доступным только в области видимости другого экземпляра или компонента, зарегистрировав его опцией <code>components</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;Пользовательский компонент!&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; будет доступен только в шаблоне родителя</span></span><br><span class="line">    <span class="string">'my-component'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Аналогичные принципы инкапсуляции применимы и для всех остальных регистрируемых пользовательских расширений Vue, например для директив.</p>
<h3 id="Особенности-парсинга-DOM-шаблона"><a href="#Особенности-парсинга-DOM-шаблона" class="headerlink" title="Особенности парсинга DOM-шаблона"></a>Особенности парсинга DOM-шаблона</h3><p>Если в качестве шаблона используется DOM (то есть в опции <code>el</code> указана точка монтирования, уже содержащая контент), это накладывает определённые ограничения, обусловленные самим языком HTML. Тогда содержимое шаблона поступает во Vue только <strong>после</strong> того, как браузер распарсит и нормализует HTML-страницу. При этом определённые сочетания элементов могут не соответствовать нормам языка HTML. Например, есть ограничение, какие элементы могут находиться внутри элементов <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> и <code>&lt;select&gt;</code>. Для некоторых других элементов, например для <code>&lt;option&gt;</code>, подобным же образом ограничен список допустимых родительских элементов.</p>
<p>С такими элементами пользовательские компоненты могут работать некорректно. Рассмотрим пример:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-row</span>&gt;</span>...<span class="tag">&lt;/<span class="name">my-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Пользовательский компонент <code>&lt;my-row&gt;</code> будет отброшен браузером как некорректный, что в конечном итоге приведёт к ошибке во время рендеринга. Обойти эту проблему можно, используя специальный атрибут <code>is</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Стоит заметить, что эти ограничения не действуют, если шаблоны получены из следующих источников</strong>:</p>
<ul>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li>шаблонные inline-строки JavaScript</li>
<li><code>.vue</code>-компоненты</li>
</ul>
<p>Поэтому мы советуем, по возможности, всегда использовать строковые шаблоны.</p>
<h3 id="Опция-data-должна-быть-функцией"><a href="#Опция-data-должна-быть-функцией" class="headerlink" title="Опция data должна быть функцией"></a>Опция <code>data</code> должна быть функцией</h3><p>Большую часть опций, которые можно передавать в конструктор Vue, допускается использовать и в компонентах. Есть одно важное исключение: опция <code>data</code> должна быть функцией. Попытаемся выполнить следующий код:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'привет!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Vue остановится и выведет в консоль предупреждение, что опция <code>data</code> в компонентах должна быть функцией. Тем не менее, неплохо бы понимать, почему существуют такие правила — так что давайте немного схитрим:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'simple-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  <span class="comment">// технически, data является функцией, так что Vue</span></span><br><span class="line">  <span class="comment">// не будет жаловаться, но при каждом вызове эта функция</span></span><br><span class="line">  <span class="comment">// возвращает ссылку на один и тот же объект компонента</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div id="example-2" class="demo">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
<script>
var data = { counter: 0 }
Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return data
  }
})
new Vue({
  el: '#example-2'
})
</script>

<p>Какая неожиданность! Увеличение одного из счётчиков также увеличит и остальные два, поскольку все они используют один и тот же объект <code>data</code>. Исправим ошибку: пусть функция при каждом вызове возвращает вновь созданный объект data.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Теперь у каждого счётчика есть своё собственное внутреннее состояние:</p>

<div id="example-2-5" class="demo">
  <my-component></my-component>
  <my-component></my-component>
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  }
})
new Vue({
  el: '#example-2-5'
})
</script>

<h3 id="Композиция-компонентов"><a href="#Композиция-компонентов" class="headerlink" title="Композиция компонентов"></a>Композиция компонентов</h3><p>Компоненты обычно используются совместно, в основном в рамках иерархических отношений, когда компонент-родитель A ссылается на компонент-потомок Б в своём собственном шаблоне. Для этого нужно обеспечить коммуникацию компонентов друг с другом. Например, родитель может передавать данные потомку, а потомок, в свою очередь, может уведомлять родителя о произошедших событиях. С помощью чётко заданного интерфейса взаимодействие между компонентами сводится к необходимому минимуму. Благодаря такому подходу можно писать и анализировать код каждого компонента в условиях относительной изоляции. Это упрощает поддержку и потенциально облегчает повторное использование компонентов.</p>
<p>Во Vue иерархические отношения подчиняются следующему принципу: <strong>“входные параметры — вниз, события — вверх” (“props down, events up”)</strong>. Родитель передаёт данные потомку через <strong>входные параметры (props)</strong>, а потомок посылает сообщения родителю посредством <strong>событий (events)</strong>. Давайте посмотрим как это работает.</p>
<p style="text-align: center;"><br>  <img style="width: 300px;" src="/images/props-events.png" alt="props down, events up"><br></p>

<h2 id="Входные-параметры"><a href="#Входные-параметры" class="headerlink" title="Входные параметры"></a>Входные параметры</h2><h3 id="Передача-данных-через-входные-параметры"><a href="#Передача-данных-через-входные-параметры" class="headerlink" title="Передача данных через входные параметры"></a>Передача данных через входные параметры</h3><p>Каждый экземпляр компонента имеет свою собственную <strong>изолированную область видимости</strong>. Поэтому напрямую обращаться к данным родительского компонента из шаблона компонента-потомка невозможно (да это и не требуется). Вместо этого данные передаются вниз по цепочке иерархии с помощью <strong>входных параметров</strong>.</p>
<p>Входной параметр — это пользовательский атрибут для передачи информации из родительского компонента. Ожидаемые входные параметры нужно явно определить в потомке с помощью <a href="../api/#props">опции <code>props</code></a>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// определяем входной параметр</span></span><br><span class="line">  props: [<span class="string">'message'</span>],</span><br><span class="line">  <span class="comment">// как и другие данные, входной параметр можно использовать</span></span><br><span class="line">  <span class="comment">// внутри шаблонов (а также и в методах, обращаясь через this.message)</span></span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Мы можем передать в компонент строку, например так:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">"привет!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Результатом будет:</p>

<div id="prop-example-1" class="demo">
  <child message="привет!"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['message'],
      template: '<span>{{ message }}</span>'
    }
  }
})
</script>

<h3 id="camelCase-против-kebab-case"><a href="#camelCase-против-kebab-case" class="headerlink" title="camelCase против kebab-case"></a>camelCase против kebab-case</h3><p>Атрибуты HTML являются регистронезависимыми, так что <strong>при использовании в DOM в качестве шаблона</strong> вместо camelCase-версий имён входных параметров приходится применять их kebab-case эквиваленты (разделять слова дефисом):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// camelCase в JavaScript</span></span><br><span class="line">  props: [<span class="string">'myMessage'</span>],</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- kebab-case в HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">my-message</span>=<span class="string">"привет!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Впрочем, строковые шаблоны не накладывают и этого ограничения.</p>
<h3 id="Динамические-входные-параметры"><a href="#Динамические-входные-параметры" class="headerlink" title="Динамические входные параметры"></a>Динамические входные параметры</h3><p>С помощью директивы <code>v-bind</code> входные параметры можно динамически связывать с данными родительского компонента аналогично тому, как обычные атрибуты связываются с выражениями. Любое обновление данных в родителе в этом случае будет передано и в компонент-потомок:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"prop-example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"parentMsg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#prop-example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMsg: <span class="string">'Сообщение из родителя'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Зачастую проще использовать для <code>v-bind</code> сокращённую запись:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Результат:</p>

<div id="demo-2" class="demo">
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Сообщение из родителя'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{ myMessage }}</span>'
    }
  }
})
</script>

<p>Если вы хотите передать все свойства объекта в качестве параметров, вы можете использовать <code>v-bind</code> без аргументов (<code>v-bind</code> вместо <code>v-bind:prop-name</code>). К примеру для объекта <code>todo</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">todo: &#123;</span><br><span class="line">  text: <span class="string">'Learn Vue'</span>,</span><br><span class="line">  isComplete: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Запись:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-bind</span>=<span class="string">"todo"</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Будет эквивалентна:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-item</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:text</span>=<span class="string">"todo.text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:is-complete</span>=<span class="string">"todo.isComplete"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Различие-между-литералами-и-динамическими-параметрами"><a href="#Различие-между-литералами-и-динамическими-параметрами" class="headerlink" title="Различие между литералами и динамическими параметрами"></a>Различие между литералами и динамическими параметрами</h3><p>Часто встречается ошибка, когда число передаётся компоненту напрямую в виде константы:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- при такой записи в компонент будет передана строка "1" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Так как в качестве параметра передан литерал, компонент получит не число, а строку <code>&quot;1&quot;</code>. Для передачи числа нужно использовать директиву <code>v-bind</code>, поскольку её значение вычисляется как выражение JavaScript:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- этот синтаксис позволит передать в компонент число --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Однонаправленный-поток-данных"><a href="#Однонаправленный-поток-данных" class="headerlink" title="Однонаправленный поток данных"></a>Однонаправленный поток данных</h3><p>Входные параметры обеспечивают <strong>однонаправленный</strong> поток данных от родительского компонента к потомкам. Если свойство компонента-родителя изменилось, это изменение передаётся потомку, но не наоборот. Если бы потомки могли произвольно изменять состояние родителя, понять структуру потоков данных внутри приложения было бы намного труднее. Благодаря однонаправленным потокам такая ситуация исключается.</p>
<p>Кроме того, при любом обновлении родительского компонента каждый входной параметр потомка обновляется до актуального значения. Поэтому <strong>не следует изменять значения</strong> входных параметров внутри компонента и расчитывать на их сохранность. При попытке изменить входной параметр Vue выведет предупреждение в консоли.</p>
<p>Новички обычно пытаются изменить значение входного параметра в двух случаях:</p>
<ol>
<li><p>Если параметр нужен лишь для передачи потомку начального значения, после чего планируется использовать эту переменную как локальную.</p>
</li>
<li><p>Если значению, которое передаётся как параметр, требуется дальнейшая обработка.</p>
</li>
</ol>
<p>Правильное решение этих задач следующее:</p>
<ol>
<li><p>Объявить локальную переменную, которая принимает значение входного параметра при инициализации:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="keyword">this</span>.initialCounter &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Определить вычисляемое свойство, основанное на значении входного параметра:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p class="tip">Обратите внимание, что объекты и массивы в JavaScript передаются по ссылке, так что если входным параметром является объект или массив, его изменение внутри потомка <strong>повлияет</strong> на состояние родительского компонента.</p>

<h3 id="Валидация-входных-параметров"><a href="#Валидация-входных-параметров" class="headerlink" title="Валидация входных параметров"></a>Валидация входных параметров</h3><p>В компонентах можно не только указать список ожидаемых параметров, но и предъявить к этим параметрам определённые требования. Если полученные параметры не удовлетворяют требованиям, Vue выведет предупреждение. Эта возможность особенно полезна при создании компонентов для внешнего использования.</p>
<p>Вместо определения списка параметров с помощью массива строк, можно использовать объект с правилами валидации:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// простая проверка типа (`null` означает допустимость любого типа)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// несколько допустимых типов</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// обязательное значение строкового типа</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// число со значением по умолчанию</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// значения по умолчанию для объектов и массивов</span></span><br><span class="line">    <span class="comment">// должны задаваться через функцию</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'привет!'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// пользовательская функция для валидации</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>В качестве параметра <code>type</code> используется один из нижеперечисленных нативных конструкторов:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Function</li>
<li>Object</li>
<li>Array</li>
<li>Symbol</li>
</ul>
<p>Кроме того, <code>type</code> может быть и пользовательской функцией-конструктором. При этом проверка соответствия выполняется с помощью <code>instanceof</code>.</p>
<p>При ошибке валидации входных параметров Vue выведет предупреждение в консоли (при использовании development-сборки). Обратите внимание, что входные параметры валидируются <strong>до создания</strong> экземпляра компонента, поэтому в функциях <code>default</code> или <code>validator</code> свойства экземпляра, такие как <code>data</code>, <code>computed</code> или <code>methods</code>, будут недоступны.</p>
<h2 id="Передача-обычных-атрибутов"><a href="#Передача-обычных-атрибутов" class="headerlink" title="Передача обычных атрибутов"></a>Передача обычных атрибутов</h2><p>Обычные атрибуты — это атрибуты, передаваемые в компонент, но не имеющие соответствующего входного параметра в компоненте.</p>
<p>Хотя явно определённые свойства предпочтительны для передачи информации дочернему компоненту, авторы библиотек компонентов не всегда могут предвидеть все контексты, в которых будут использованы их компоненты. Вот почему компоненты могут принимать произвольные атрибуты, которые добавляются в корневой элемент компонента.</p>
<p>Например, представьте, что мы используем сторонний компонент <code>bs-date-input</code> с плагином Bootstrap, который требует указания атрибута <code>data-3d-date-picker</code> на элементе <code>input</code>. Мы можем добавить этот атрибут к нашему экземпляру компонента:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bs-date-input</span> <span class="attr">data-3d-date-picker</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">bs-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>И атрибут <code>data-3d-date-picker=&quot;true&quot;</code> будет автоматически добавлен в корневой элемент <code>bs-date-input</code>.</p>
<h3 id="Замена-Объединение-существующих-атрибутов"><a href="#Замена-Объединение-существующих-атрибутов" class="headerlink" title="Замена/Объединение существующих атрибутов"></a>Замена/Объединение существующих атрибутов</h3><p>Представьте, что это шаблон для <code>bs-date-input</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Чтобы добавить тему для нашего плагина выбора даты, нам может понадобиться добавить определённый класс, например:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bs-date-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-3d-date-picker</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"date-picker-theme-dark"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">bs-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>В этом случае определены два разных значения для <code>class</code>:</p>
<ul>
<li><code>form-control</code>, который задаётся компонентом в его шаблоне</li>
<li><code>date-picker-theme-dark</code>, который передаётся компоненту его родителем</li>
</ul>
<p>Для большинства атрибутов значение, предоставляемое компоненту, будет заменять значение, заданное компонентом. Например, передача <code>type=&quot;large&quot;</code> будет заменять <code>type=&quot;date&quot;</code> и, вероятно, ломать всё! К счастью, работа с атрибутами <code>class</code> и <code>style</code> немного умнее, поэтому оба значения будут объединены в итоговое значение: <code>form-control date-picker-theme-dark</code>.</p>
<h2 id="Пользовательские-события"><a href="#Пользовательские-события" class="headerlink" title="Пользовательские события"></a>Пользовательские события</h2><p>Мы узнали, что компонент-родитель может передавать данные потомкам через входные параметры. Но как организовать связь в обратном направлении? Самое время поговорить о системе пользовательских событий Vue.</p>
<h3 id="Использование-v-on-с-пользовательскими-событиями"><a href="#Использование-v-on-с-пользовательскими-событиями" class="headerlink" title="Использование v-on с пользовательскими событиями"></a>Использование <code>v-on</code> с пользовательскими событиями</h3><p>Каждый экземпляр Vue поддерживает <a href="../api/#Методы-экземпляра-—-события">интерфейс событий</a>, позволяющий:</p>
<ul>
<li>Отслеживать события, используя <code>$on(eventName)</code></li>
<li>Порождать события, используя <code>$emit(eventName, optionalPayload)</code></li>
</ul>
<p class="tip">Обратите внимание, что система событий Vue отделена от <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget API</a> браузера. Хотя они и похожи, <code>$on</code> и <code>$emit</code> — это не псевдонимы <code>addEventListener</code> и <code>dispatchEvent</code>.</p>

<p>Кроме того, родительский компонент может зарегистрировать подписчика событий, используя директиву <code>v-on</code> непосредственно в шаблоне при создании компонента-потомка.</p>
<p class="tip">Вы не можете использовать <code>$on</code> для прослушивания событий, генерируемых в потомках. Вы должны использовать <code>v-on</code> непосредственно в шаблоне, как в приведённом ниже примере.</p>

<p>Вот пример:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter-event-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementCounter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#counter-event-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.total += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div id="counter-event-example" class="demo">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
<script>
Vue.component('button-counter', {
  template: '<button v-on:click="incrementCounter">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    incrementCounter: function () {
      this.counter += 1
      this.$emit('increment')
    }
  }
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</script>

<p>Важно отметить, что потомок остаётся полностью независимым от всего происходящего снаружи. Он всего лишь уведомляет внешний мир о происходящем с ним, на случай, если родительскому компоненту это будет интересно.</p>
<p>Вот пример использования данных полезной нагрузки:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message-event-example"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"msg in messages"</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-message</span> <span class="attr">v-on:message</span>=<span class="string">"handleMessage"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-message'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type="text" v-model="message" /&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click="handleSendMessage"&gt;Отправить&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'тестовое сообщение'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSendMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'message'</span>, &#123; <span class="attr">message</span>: <span class="keyword">this</span>.message &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#message-event-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    messages: []</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleMessage: <span class="function"><span class="keyword">function</span> (<span class="params">payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.messages.push(payload.message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div id="message-event-example" class="demo">
  <p v-for="msg in messages">{{ msg }}</p>
  <button-message v-on:message="handleMessage"></button-message>
</div>
<script>
Vue.component('button-message', {
  template: `<div>
    <input type="text" v-model="message" />
    <button v-on:click="handleSendMessage">Отправить</button>
  </div>`,
  data: function () {
    return {
      message: 'тестовое сообщение'
    }
  },
  methods: {
    handleSendMessage: function () {
      this.$emit('message', { message: this.message })
    }
  }
})
new Vue({
  el: '#message-event-example',
  data: {
    messages: []
  },
  methods: {
    handleMessage: function (payload) {
      this.messages.push(payload.message)
    }
  }
})
</script>

<p>В этом втором примере важно отметить, что дочерний компонент всё ещё остаётся полностью независимым от всего происходящего снаружи. Он всего лишь уведомляет внешний мир о происходящем с ним, включая данные полезной нагрузки в генераторе событий (event emitter), на случай, если родительскому компоненту это будет интересно.</p>
<h3 id="Подписка-на-нативные-события-в-компонентах"><a href="#Подписка-на-нативные-события-в-компонентах" class="headerlink" title="Подписка на нативные события в компонентах"></a>Подписка на нативные события в компонентах</h3><p>Иногда нужно подписаться на нативные события браузера в корневом элементе компонента. В таких случаях можно применить <code>v-on</code> с модификатором <code>.native</code>, например так:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">"doTheThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Модификатор-sync"><a href="#Модификатор-sync" class="headerlink" title="Модификатор .sync"></a>Модификатор <code>.sync</code></h3><blockquote>
<p>Добавлено в версии 2.3.0+</p>
</blockquote>
<p>В некоторых случаях нам может понадобиться “двухсторонняя привязка” для входных данных — фактически, во Vue 1.x это было представлено модификатором <code>.sync</code>. Когда дочерний компонент изменяет параметр входных данных (prop) с модификатором <code>.sync</code>, изменение значения будет отражено в родительском компоненте. Это удобно, однако в долгосрочной перспективе может привести к усложнению поддержки, поскольку это нарушает предположение об одностороннем потоке данных: код, который мутирует дочерние входные данные, неявно затрагивает родительское состояние.</p>
<p>Вот почему мы удалили модификатор <code>.sync</code>, когда была выпущена версия 2.0. Тем не менее, мы обнаружили, что действительно есть случаи когда это может быть полезно, особенно при реализации переиспользуемых компонентов. Что нам требовалось изменить, это <strong>сделать код в потомке, который влияет на родительское состояние более последовательным и явным</strong>.</p>
<p>В версии 2.3.0+ мы снова ввели модификатор <code>.sync</code> для входных данных, но на этот раз это просто синтаксический сахар, который автоматически преобразуется в дополнительный обработчик <code>v-on</code>:</p>
<p>Следующее</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo.sync</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>будет преобразовано в:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo</span>=<span class="string">"bar"</span> @<span class="attr">update:foo</span>=<span class="string">"val =&gt; bar = val"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Чтобы дочерний компонент обновлял значение <code>foo</code>, он должен явно генерировать событие, вместо изменения параметра входных данных:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:foo'</span>, newValue)</span><br></pre></td></tr></table></figure>
<p>Модификатор <code>.sync</code> также может использоваться с <code>v-bind</code> при использовании объекта для установки одновременно нескольких свойств:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind.sync</span>=<span class="string">"&#123; foo: 1, bar: 2 &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Это приводит к добавлению обработчика <code>v-on</code> при обновлении как <code>foo</code>, так и <code>bar</code>.</p>
<h3 id="Поля-ввода-форм-с-использованием-пользовательских-событий"><a href="#Поля-ввода-форм-с-использованием-пользовательских-событий" class="headerlink" title="Поля ввода форм с использованием пользовательских событий"></a>Поля ввода форм с использованием пользовательских событий</h3><p>С помощью пользовательских событий можно также создавать пользовательские поля ввода с поддержкой директивы <code>v-model</code>. Вспомните, что</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"something"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>это всего лишь синтаксический сахар для:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"something"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"something = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>При использовании с компонентом вместо этого упрощается:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">"something"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"value =&gt; &#123; something = value &#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Таким образом, чтобы иметь возможность работать с <code>v-model</code>, компонент может (это настраивается в версиях 2.2.0+):</p>
<ul>
<li>принимать входной параметр <code>value</code></li>
<li>порождать событие <code>input</code> с новым значением</li>
</ul>
<p>Давайте разберём в качестве примера простое поле ввода денежной суммы с точкой в качестве десятичного разделителя:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">v-model</span>=<span class="string">"price"</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'currency-input'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;span&gt;\</span></span><br><span class="line"><span class="string">      $\</span></span><br><span class="line"><span class="string">      &lt;input\</span></span><br><span class="line"><span class="string">        ref="input"\</span></span><br><span class="line"><span class="string">        v-bind:value="value"\</span></span><br><span class="line"><span class="string">        v-on:input="updateValue($event.target.value)"\</span></span><br><span class="line"><span class="string">      &gt;\</span></span><br><span class="line"><span class="string">    &lt;/span&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// Вместо того, чтобы обновлять значение напрямую,</span></span><br><span class="line">    <span class="comment">// в этом методе мы выполняем нормализацию и форматирование</span></span><br><span class="line">    <span class="comment">// введённого значения, а затем порождаем событие,</span></span><br><span class="line">    <span class="comment">// уведомляющее родительский компонент об изменениях</span></span><br><span class="line">    updateValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> formattedValue = value</span><br><span class="line">        <span class="comment">// Удалить пробелы с обеих сторон</span></span><br><span class="line">        .trim()</span><br><span class="line">        <span class="comment">// Сократить до 2 знаков после запятой</span></span><br><span class="line">        .slice(</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          value.indexOf(<span class="string">'.'</span>) === <span class="number">-1</span></span><br><span class="line">            ? value.length</span><br><span class="line">            : value.indexOf(<span class="string">'.'</span>) + <span class="number">3</span></span><br><span class="line">        )</span><br><span class="line">      <span class="comment">// Если значение не нормализовано — нормализуем вручную</span></span><br><span class="line">      <span class="keyword">if</span> (formattedValue !== value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.input.value = formattedValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Порождаем событие с обновлённым значением поля ввода</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="built_in">Number</span>(formattedValue))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div id="currency-input-example" class="demo">
  <currency-input v-model="price"></currency-input>
</div>
<script>
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    updateValue: function (value) {
      var formattedValue = value
        .trim()
        .slice(
          0,
          value.indexOf('.') === -1
            ? value.length
            : value.indexOf('.') + 3
        )
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      this.$emit('input', Number(formattedValue))
    }
  }
})
new Vue({
  el: '#currency-input-example',
  data: { price: '' }
})
</script>

<p>Очевидно, что наша реализация не лишена недостатков. Например, пользователь может ввести несколько десятичных точек, а кое-где и буквы вместо цифр. Для тех, кого интересует пример менее тривиальной и более надёжной реализации, вот он:</p>
<iframe width="100%" height="300" src="https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h3 id="Настройка-v-model-у-компонента"><a href="#Настройка-v-model-у-компонента" class="headerlink" title="Настройка v-model у компонента"></a>Настройка <code>v-model</code> у компонента</h3><blockquote>
<p>Добавлено в версии 2.2.0+</p>
</blockquote>
<p>По умолчанию <code>v-model</code> на компоненте использует входной параметр <code>value</code> и событие <code>input</code>. Но некоторые типы полей, такие как чекбоксы или радиокнопки, могут использовать входной параметр <code>value</code> для других целей. Использование опции <code>model</code> позволит избежать конфликта в таких случаях:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="comment">// это позволит использовать входной параметр `value` для других целей</span></span><br><span class="line">    value: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span> <span class="attr">v-model</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Указанное выше эквивалентно:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:checked</span>=<span class="string">"foo"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">change</span>=<span class="string">"val =&gt; &#123; foo = val &#125;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p class="tip">Обратите внимание, что вам всё равно необходимо явно объявить <code>checked</code> во входных данных.</p>

<h3 id="Коммуникация-между-компонентами-не-связанными-иерархически"><a href="#Коммуникация-между-компонентами-не-связанными-иерархически" class="headerlink" title="Коммуникация между компонентами, не связанными иерархически"></a>Коммуникация между компонентами, не связанными иерархически</h3><p>Иногда нужно обеспечить обмен информацией между компонентами, которые не состоят в отношениях родитель-потомок. В простых случаях можно использовать пустой экземпляр Vue в качестве глобальной шины событий:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// в методе компонента A</span></span><br><span class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// в обработчике created компонента B</span></span><br><span class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Для более сложных случаев подойдёт специализированный <a href="state-management.html">паттерн управления состоянием приложением</a>.</p>
<h2 id="Распределение-контента-слотами"><a href="#Распределение-контента-слотами" class="headerlink" title="Распределение контента слотами"></a>Распределение контента слотами</h2><p>Нередко хочется вкладывать компоненты друг в друга следующим образом:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">app-footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Здесь стоит обратить внимание на две вещи:</p>
<ol>
<li><p>Компонент <code>&lt;app&gt;</code> не знает, какой контент будет ему передан. Это определяется компонентом, использующим <code>&lt;app&gt;</code>.</p>
</li>
<li><p>Скорее всего, у компонента <code>&lt;app&gt;</code> есть собственный шаблон.</p>
</li>
</ol>
<p>Чтобы такая композиция работала, необходим метод “переплетения” шаблона компонента и внутреннего содержимого, указанного при его использовании в родительском контексте. Этот процесс называется <strong>распределением контента</strong>, или, в терминах Angular, “включением” (“transclusion”). Во Vue.js реализован API распределения контента, примерно соответствующий текущему <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">черновику спецификации Web Components</a>. В нём используется специальный элемент <code>&lt;slot&gt;</code>, служащий “точкой выхода” для исходного контента.</p>
<h3 id="Область-видимости-при-компиляции"><a href="#Область-видимости-при-компиляции" class="headerlink" title="Область видимости при компиляции"></a>Область видимости при компиляции</h3><p>Перед тем как углубиться в рассмотрение API слотов, давайте сперва разберёмся, в какой области видимости компилируется содержимое шаблонов. Представим такой шаблон:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Из какого контекста берётся переменная <code>message</code>, контекста родителя или контекста потомка? Правильный ответ — из контекста родителя. Действует простое правило:</p>
<blockquote>
<p>Всё в шаблоне родительского компонента компилируется в области видимости родителя; всё в шаблоне потомка — в области видимости потомка.</p>
</blockquote>
<p>Часто встречается ошибка, когда в шаблоне родителя указывается связывание со свойством компонента-потомка:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- НЕ сработает --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-show</span>=<span class="string">"someChildProperty"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Если <code>someChildProperty</code> является свойством потомка, вышеприведённый пример работать не будет. Шаблон родителя не имеет никакого представления о состоянии компонента-потомка.</p>
<p>Если всё-таки нужно привязать директивы из области видимости компонента-потомка к корневому элементу, это необходимо сделать в его же шаблоне:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// такой вариант сработает, поскольку мы находимся</span></span><br><span class="line">  <span class="comment">// в правильной области видимости</span></span><br><span class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      someChildProperty: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Контент, полученный через систему распределения, также будет компилироваться в родительской области видимости.</p>
<h3 id="Вариант-с-единственным-слотом"><a href="#Вариант-с-единственным-слотом" class="headerlink" title="Вариант с единственным слотом"></a>Вариант с единственным слотом</h3><p>Родительский контент будет <strong>отброшен</strong>, если в шаблоне компонента-потомка нет хотя бы одного элемента <code>&lt;slot&gt;</code>. В случае, если слот всего один и не содержит атрибутов, всё содержимое родительского элемента будет помещено в DOM на место слота, замещая его собой.</p>
<p>Изначальное содержимое тега <code>&lt;slot&gt;</code> считается <strong>резервным контентом</strong>. Оно компилируется в области видимости компонента-потомка и отображается только в том случае, если родительский элемент пуст и не содержит никакого контента для передачи потомку.</p>
<p>Предположим, у нас есть компонент <code>my-component</code> с таким шаблоном:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Заголовок компонента-потомка<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">    Этот текст будет отображён, только если</span><br><span class="line">    не будет передано контента для распределения.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>И родитель, использующий этот компонент:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Заголовок компонента-родителя<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Немного оригинального контента<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>И ещё немного<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Результатом рендеринга будет:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Заголовок компонента-родителя<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Заголовок компонента-потомка<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Немного оригинального контента<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>И ещё немного<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Именованные-слоты"><a href="#Именованные-слоты" class="headerlink" title="Именованные слоты"></a>Именованные слоты</h3><p>Для элементов <code>&lt;slot&gt;</code> можно указать специальный атрибут <code>name</code>, который используется для ещё более гибкого распределения контента. Можно создать несколько слотов с различными именами. Именованный слот получит весь контент, находящийся в элементе с соответствующим значением атрибута <code>slot</code>.</p>
<p>Если одному из слотов не задать имя, он станет <strong>слотом по умолчанию</strong>, в который попадёт весь контент, для которого имя слота не указано. В случае отсутствия безымянного слота, такой контент будет попросту отброшен.</p>
<p>Для примера, предположим что у нас есть компонент <code>app-layout</code> с таким шаблоном:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Шаблон родителя:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>Здесь мог бы быть заголовок страницы<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Абзац основного контента.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>И ещё один.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>Вот контактная информация<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Результатом рендеринга будет:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Здесь мог бы быть заголовок страницы<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Абзац основного контента.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>И ещё один.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Вот контактная информация<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>API распределения контента — это очень полезный механизм для создания компонентов, которые будут использоваться совместно.</p>
<h3 id="Слоты-с-ограниченной-областью-видимости"><a href="#Слоты-с-ограниченной-областью-видимости" class="headerlink" title="Слоты с ограниченной областью видимости"></a>Слоты с ограниченной областью видимости</h3><blockquote>
<p>Добавлено в версии 2.1.0+</p>
</blockquote>
<p>Слот с ограниченной областью видимости — это особый тип слота, который применяется как повторно используемый шаблон, то есть в этот слот передаются данные, а не уже отрендеренные элементы.</p>
<p>В компоненте-потомке нужно просто передать данные в слот, так же как входные параметры передаются в компонент:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">text</span>=<span class="string">"сообщение от потомка"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>В родительском элементе должен существовать элемент <code>&lt;template&gt;</code> со специальным атрибутом <code>slot-scope</code>, что указывает на то, что он является шаблоном для слота с ограниченной областью видимости. Значение <code>slot-scope</code> будет использовано в качестве имени временной переменной, содержащей входные параметры, переданные от потомка:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>сообщение от родителя<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Результатом рендеринга кода выше будет:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>сообщение от родителя<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>сообщение от потомка<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>С версии 2.5.0+ <code>slot-scope</code> больше не ограничивается тегом <code>&lt;template&gt;</code> и может использоваться для любого элемента или компонента.</p>
</blockquote>
<p>Более характерное применение для слотов с ограниченной областью видимости — это компонент, выводящий список элементов, в котором пользователь может переопределить вид элемента:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-awesome-list</span> <span class="attr">:items</span>=<span class="string">"items"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- слот с ограниченной областью видимости может быть и именованным --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot-scope</span>=<span class="string">"props"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"my-fancy-item"</span>&gt;</span></span><br><span class="line">    &#123;&#123; props.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-awesome-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>И шаблон самого компонента списка:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"item in items"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:text</span>=<span class="string">"item.text"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- здесь — контент для резервного отображения --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Деструктурирование"><a href="#Деструктурирование" class="headerlink" title="Деструктурирование"></a>Деструктурирование</h4><p>Значение <code>slot-scope</code> на самом деле является валидным выражением JavaScript, которое может использоваться в аргументе сигнатуры функции. Это означает, что в поддерживаемых окружениях (в однофайловых компонентах или в современных браузерах) вы также можете использовать деструктурирование ES2015 в выражениях:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; text &#125;"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Динамическое-переключение-компонентов"><a href="#Динамическое-переключение-компонентов" class="headerlink" title="Динамическое переключение компонентов"></a>Динамическое переключение компонентов</h2><p>Можно подключить несколько компонентов к одной и той же точке монтирования, а затем динамически переключаться между ними. Для этого используется псевдоэлемент <code>&lt;component&gt;</code> и динамическое связывание его атрибута <code>is</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: <span class="string">'home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    posts: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    archive: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- изменяя vm.currentView можно переключаться между компонентами --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>При желании можно связываться с объектами компонентов и напрямую:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Home = &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;Добро пожаловать домой!&lt;/p&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: Home</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><code>keep-alive</code></h3><p>Иногда бывает выгодно хранить отключённые компоненты в памяти, чтобы не терять их состояния и не выполнять их повторный рендеринг. Для этого нужно обернуть динамический компонент в псевдоэлемент <code>&lt;keep-alive&gt;</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- неактивные компоненты будут закешированы! --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Более детально <code>&lt;keep-alive&gt;</code> рассмотрен в <a href="../api/#keep-alive">справочнике по API</a>.</p>
<h2 id="Разное"><a href="#Разное" class="headerlink" title="Разное"></a>Разное</h2><h3 id="Создание-компонентов-для-повторного-использования"><a href="#Создание-компонентов-для-повторного-использования" class="headerlink" title="Создание компонентов для повторного использования"></a>Создание компонентов для повторного использования</h3><p>Создавая компоненты, неплохо понимать, планируется ли использовать их где-то ещё в будущем. Если компоненты одноразовые, они могут быть и сильно связанными. В компонентах, предназначенных для повторного использования, следует определить чёткий публичный интерфейс, в котором нет излишних предположений о контексте использования компонента.</p>
<p>API компонентов Vue состоит из трёх частей: входных параметров, событий и слотов:</p>
<ul>
<li><p><strong>Входные параметры</strong> позволяют передавать в компонент данные извне.</p>
</li>
<li><p><strong>События</strong> позволяют компонентам воздействовать на внешнее окружение.</p>
</li>
<li><p><strong>Слоты</strong> позволяют внешнему окружению дополнять компоненты новым контентом.</p>
</li>
</ul>
<p>Благодаря специальному сокращённому синтаксису <code>v-bind</code> и <code>v-on</code>, назначение компонента можно коротко и ясно выразить в шаблоне:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:foo</span>=<span class="string">"baz"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:bar</span>=<span class="string">"qux"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">event-a</span>=<span class="string">"doThis"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">event-b</span>=<span class="string">"doThat"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"main-text"</span>&gt;</span>Привет!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Ссылки-на-компоненты-потомки"><a href="#Ссылки-на-компоненты-потомки" class="headerlink" title="Ссылки на компоненты-потомки"></a>Ссылки на компоненты-потомки</h3><p>Несмотря на существование таких средств, как входные параметры и события, иногда всё же возникает необходимость обратиться к компонентам-потомкам в JavaScript напрямую. Для этих целей можно при помощи атрибута <code>ref</code> назначить компоненту идентификатор. Например:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user-profile</span> <span class="attr">ref</span>=<span class="string">"profile"</span>&gt;</span><span class="tag">&lt;/<span class="name">user-profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#parent'</span> &#125;)</span><br><span class="line"><span class="comment">// получаем экземпляр компонента-потомка</span></span><br><span class="line"><span class="keyword">var</span> child = parent.$refs.profile</span><br></pre></td></tr></table></figure>
<p>Когда <code>ref</code> используется вместе с директивой <code>v-for</code>, будет возвращаться массив ссылок на экземпляры, структурно повторяющий исходные данные.</p>
<p class="tip">Объект <code>$refs</code> заполняется только после рендеринга компонента и не является реактивным. Считайте, что это крайнее средство для непосредственного вмешательства в работу компонента-потомка, и не используйте <code>$refs</code> в шаблонах и вычисляемых свойствах.</p>

<h3 id="Асинхронные-компоненты"><a href="#Асинхронные-компоненты" class="headerlink" title="Асинхронные компоненты"></a>Асинхронные компоненты</h3><p>Иногда бывает удобно разделить крупное приложение на части и подгружать компоненты с сервера только тогда, когда в них возникнет потребность. Для этого Vue позволяет определить компонент как функцию-фабрику, асинхронно возвращающую определение компонента. Vue вызовет фабричную функцию только тогда, когда компонент действительно понадобится, и закеширует результат для дальнейшего использования. Например:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Передаём шаблон компонента в коллбэк resolve</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;Я — асинхронный!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Функция-фабрика принимает параметр <code>resolve</code> — коллбэк, который вызывается после того, как определение компонента получено от сервера. Кроме того, можно вызвать <code>reject(reason)</code>, если загрузка по какой-либо причине не удалась. Мы используем <code>setTimeout</code> исключительно в демонстрационных целях; как именно получать компонент в реальной ситуации — решать только вам самим. Один из удачных подходов — это использовать асинхронные компоненты в связке с <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">функциями Webpack по разделению кода</a>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// специальный синтаксис require укажет Webpack</span></span><br><span class="line">  <span class="comment">// автоматически разделить сборку на части</span></span><br><span class="line">  <span class="comment">// для последующей асинхронной загрузки</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Вы также можете вернуть <code>Promise</code> в функции-фабрике, так что с Webpack 2 и синтаксисом ES2015 можно сделать так:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// Функция `import` возвращает `Promise`.</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>При использовании <a href="components.html#Локальные-компоненты">локальных компонентов</a>, вы также можете непосредственно указывать функцию, которая возвращает <code>Promise</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p class="tip">Если вы используете <strong>Browserify</strong> и также хотите реализовать асинхронную загрузку компонентов, нам, к сожалению, придётся вас огорчить. Это невозможно, и вряд ли будет возможно когда-либо, так как сам создатель Browserify <a href="https://github.com/substack/node-browserify/issues/58#issuecomment-21978224" target="_blank" rel="noopener">прояснил</a>, что асинхронная загрузка “не является функцией, которую Browserify когда-либо будет поддерживать”. По крайней мере, такова официальная позиция. Сообщество Browserify обнаружило возможные <a href="https://github.com/vuejs/vuejs.org/issues/620" target="_blank" rel="noopener">обходные пути</a>, которые могут быть полезны в уже существующих сложных приложениях. Но в целом мы советуем использовать Webpack, обладающий полноценной встроенной поддержкой асинхронной загрузки частей сборки.</p>

<h3 id="Продвинутые-асинхронные-компоненты"><a href="#Продвинутые-асинхронные-компоненты" class="headerlink" title="Продвинутые асинхронные компоненты"></a>Продвинутые асинхронные компоненты</h3><blockquote>
<p>Добавлено в версии 2.3.0+</p>
</blockquote>
<p>Начиная с версии 2.3.0+ фабрика асинхронного компонента также может возвращать объект следующего формата:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// Загружаемый компонент. Значение должно быть Promise</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComp.vue'</span>),</span><br><span class="line">  <span class="comment">// Компонент загрузки, используемый пока загружается асинхронный компонент</span></span><br><span class="line">  loading: LoadingComp,</span><br><span class="line">  <span class="comment">// Компонент ошибки, используемый при неудачной загрузке</span></span><br><span class="line">  error: ErrorComp,</span><br><span class="line">  <span class="comment">// Задержка перед показом компонента загрузки. По умолчанию: 200 мс.</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// Компонент ошибки будет отображаться, если тайм-аут</span></span><br><span class="line">  <span class="comment">// был указан и время ожидания превышено. По умолчанию: Infinity (бесконечное ожидание).</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Обратите внимание, что при использовании в качестве компонента маршрута в <code>vue-router</code>, эти свойства будут проигнорированы, потому что асинхронные компоненты будут разрешаться до того, как будет выполнена маршрутная навигация. Вам также необходимо использовать <code>vue-router</code> версии 2.4.0+, если вы хотите использовать указанный выше синтаксис для компонентов маршрута.</p>
<h3 id="Соглашения-по-именованию-компонентов"><a href="#Соглашения-по-именованию-компонентов" class="headerlink" title="Соглашения по именованию компонентов"></a>Соглашения по именованию компонентов</h3><p>При регистрации компонентов (или входных параметров), можно использовать kebab-case, camelCase или PascalCase.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// при определении компонента</span></span><br><span class="line">components: &#123;</span><br><span class="line">  <span class="comment">// регистрация с использованием kebab-case</span></span><br><span class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// регистрация с использованием camelCase</span></span><br><span class="line">  <span class="string">'camelCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// регистрация с использованием PascalCase</span></span><br><span class="line">  <span class="string">'PascalCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>В HTML-шаблонах, однако, придётся использовать эквивалентный kebab-case:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- всегда используйте kebab-case в HTML-шаблонах --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kebab-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">kebab-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">camel-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">camel-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pascal-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">pascal-cased-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>При использовании <strong>строковых</strong> шаблонов ограничения регистронезависимости HTML не действуют. Это значит, что даже в шаблоне можно указывать компоненты, используя:</p>
<ul>
<li>kebab-case</li>
<li>camelCase или kebab-case, если компонент был объявлен с помощью camelCase</li>
<li>kebab-case, camelCase или PascalCase, если компонент был объявлен с помощью PascalCase</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  camelCasedComponent: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  PascalCasedComponent: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kebab-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">kebab-cased-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">camel-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">camel-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">camelCasedComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">camelCasedComponent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pascal-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">pascal-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pascalCasedComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">pascalCasedComponent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PascalCasedComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">PascalCasedComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Это означает, что PascalCase является наиболее универсальным <em>соглашением объявления</em>, а kebab-case наиболее универсальным <em>соглашением использования</em>.</p>
<p>Если компонент не содержит слотов, его можно даже сделать самозакрывающимся, указав <code>/</code> после имени:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>Ещё раз заметим, что это возможно <strong>только при использовании строковых шаблонов</strong>, поскольку самозакрывающие пользовательские элементы не соответствуют нормам языка HTML, и нативные парсеры браузеров такую запись не поймут.</p>
<h3 id="Рекурсивные-компоненты"><a href="#Рекурсивные-компоненты" class="headerlink" title="Рекурсивные компоненты"></a>Рекурсивные компоненты</h3><p>Компоненты могут рекурсивно вызывать самих себя в своих шаблонах. Однако, эта возможность доступна только при указании опции <code>name</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'unique-name-of-my-component'</span></span><br></pre></td></tr></table></figure>
<p>Если компонент регистрируется глобально с помощью <code>Vue.component</code>, то опция <code>name</code> компонента автоматически становится равной его глобальному ID:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Если не соблюдать осторожность, рекурсивные компоненты могут привести к появлению бесконечных циклов:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>
<p>Использование такого компонента приведёт к ошибке переполнения стека, поэтому следите, чтобы рекурсивный вызов был условным (т.е. чтобы в нём была директива <code>v-if</code>, которая рано или поздно станет ложной).</p>
<h3 id="Циклические-ссылки-между-компонентами"><a href="#Циклические-ссылки-между-компонентами" class="headerlink" title="Циклические ссылки между компонентами"></a>Циклические ссылки между компонентами</h3><p>Предположим, вы проектируете каталог файлов в виде дерева, похожего на Finder или Проводник. Представьте себе, что для этого используется компонент <code>tree-folder</code> с таким шаблоном:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.children"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Затем компонент <code>tree-folder-contents</code> с таким шаблоном:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Присмотритесь к примеру. Парадоксально, но каждый из этих компонентов <strong>одновременно</strong> является и потомком, и родителем другого компонента! При глобальной регистрации компонентов с использованием <code>Vue.component</code> данный парадокс будет разрешён автоматически. Если это ваш случай, то можете дальше не читать.</p>
<p>С другой стороны, если компоненты импортируются с помощью <strong>модульного сборщика</strong>, такого как Webpack или Browserify, возникнет ошибка.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to mount component: template or render function not defined.</span><br></pre></td></tr></table></figure>
<p>Чтобы объяснить это явление, давайте назовём наши компоненты A и B. Модульный сборщик видит, что ему нужен компонент A, но A сперва нужен B, но B нужен A, и т.д. Сборщик застревает в цикле, не зная как полностью разрешить оба компонента. Чтобы это исправить, нам нужно указать сборщику точку, в которой он сможет сказать: “Рано или поздно для разрешения A нужно разрешить B, но нет необходимости разрешать B прямо сейчас.”</p>
<p>Для нашего случая, мы сделаем такой точкой компонент <code>tree-folder</code>. Мы знаем, что компонент-потомок, порождающий парадокс — это <code>tree-folder-contents</code>. Поэтому мы не будем его регистрировать, пока не наступит событие жизненного цикла <code>beforeCreate</code>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Проблема решена!</p>
<h3 id="Inline-шаблоны"><a href="#Inline-шаблоны" class="headerlink" title="Inline-шаблоны"></a>Inline-шаблоны</h3><p>Если у компонента-потомка присутствует специальный атрибут <code>inline-template</code>, содержимое элемента будет использовано не для распределения контента, а в качестве шаблона этого компонента. Это позволяет более гибко использовать шаблоны.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Этот шаблон будет скомпилирован в области видимости компонента-потомка.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Доступа к данным родителя нет.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>С другой стороны, использование <code>inline-template</code> затрудняет понимание происходящего в шаблонах. Поэтому желательно задавать шаблоны внутри компонента с помощью опции <code>template</code> или в элементе <code>template</code> файла <code>.vue</code>.</p>
<h3 id="Определение-шаблонов-через-X-Template"><a href="#Определение-шаблонов-через-X-Template" class="headerlink" title="Определение шаблонов через X-Template"></a>Определение шаблонов через X-Template</h3><p>Ещё один способ задания шаблонов — это специальные элементы <code>script</code> с типом <code>text/x-template</code> и идентификатором, на который можно сослаться при регистрации шаблона. Например:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-template"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Привет привет привет<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#hello-world-template'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Эта возможность бывает полезной для демонстрационных приложений с большими шаблонами или для очень маленьких приложений. Тем не менее, в целом такого подхода следует избегать, так как шаблоны отделяются от остальных частей определения компонента.</p>
<h3 id="“Дешёвые”-статические-компоненты-с-использованием-v-once"><a href="#“Дешёвые”-статические-компоненты-с-использованием-v-once" class="headerlink" title="“Дешёвые” статические компоненты с использованием v-once"></a>“Дешёвые” статические компоненты с использованием <code>v-once</code></h3><p>Рендеринг простых элементов HTML во Vue происходит достаточно быстро, но иногда встречаются компоненты, в которых статических данных <strong>очень</strong> много. В таком случае можно указать в корневом элементе директиву <code>v-once</code>. С этой директивой компонент будет вычислен только в первый раз, а дальнейшая работа будет происходить с закешированной версией. Например:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;\</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Условия использования&lt;/h1&gt;\</span></span><br><span class="line"><span class="string">      ... много-много статического контента ...\</span></span><br><span class="line"><span class="string">    &lt;/div&gt;\</span></span><br><span class="line"><span class="string">  '</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

    
    
      <div class="guide-links">
        
        
          <span>← <a href="/v2/guide/forms.html">Работа с формами</a></span>
        
        
        
          <span style="float: right;"><a href="/v2/guide/transitions.html">Анимирование списков и появления/исчезновения</a> →</span>
        
      </div>
    
    <div class="footer">
        <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div class="bsa-cpc"></div>
<script>
  (function(){
    if(typeof _bsa !== 'undefined' && _bsa) {
    _bsa.init('default', 'CKYD62QM', 'placement:vuejsorg', {
      target: '.bsa-cpc',
      align: 'horizontal',
      disable_css: 'true'
    });
      }
  })();
</script>

      Обнаружили ошибку или хотите добавить что-то своё в документацию?
      <a href="https://github.com/translation-gang/ru.vuejs.org/blob/master/src/v2/guide/components.md" target="_blank">
        Отредактируйте эту страницу на GitHub!
      </a>
    </div>
</div>

                
            </div>
            <script src="/js/smooth-scroll.min.js"></script>
        

        <!-- main custom script for sidebars, version selects etc. -->
        <script src="/js/css.escape.js"></script>
        <script src="/js/common.js"></script>

        <!-- search -->
        <link href="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/search.css">
        <script src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
        <script>
        [
          '#search-query-nav',
          '#search-query-sidebar',
          '#search-query-menu'
        ].forEach(function (selector) {
          if (!document.querySelector(selector)) return
          // search index defaults to v2
          var match = window.location.pathname.match(/^\/(v\d+)/)
          var version = match ? match[1] : 'v2'
          docsearch({
            appId: 'BH4D9OD16A',
            apiKey: 'c6f9366f6f7fe057ee3e01747b603d9f',
            indexName: 'vuejs_ru',
            inputSelector: selector,
            algoliaOptions: { facetFilters: ["version:" + version] }
          })
        })
        </script>

        <!-- fastclick -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script>
        document.addEventListener('DOMContentLoaded', function() {
          FastClick.attach(document.body)
        }, false)
        </script>
    </body>
</html>
